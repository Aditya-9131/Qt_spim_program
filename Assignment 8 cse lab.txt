                                      Assignment 8

1. In a library management system, the system uses a Binary Search Tree (BST) to store
information about books. Each node in the BST represents a book and contains the book’s
unique identifier (ISBN), title, author, and available quantity. The BST is sorted based on
the ISBN values, with smaller ISBNs on the left and larger ISBNs on the right.
Write a C program that implements the following operations for the library management
system:
(a) Insert a Book
Hint: Prompt the user to enter the ISBN, title, author, and available quantity of a
book. Create a new node with the provided information and insert it into the BST
based on the ISBN value. If a book with the same ISBN already exists in the BST,
update the available quantity instead.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int isbn;
    char title[100];
    char author[100];
    int quantity;
    struct Node* left;
    struct Node* right;
} Node;

Node* createNode(int isbn, char* title, char* author, int quantity) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->isbn = isbn;
    strcpy(newNode->title, title);
    strcpy(newNode->author, author);
    newNode->quantity = quantity;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

Node* insertNode(Node* root, int isbn, char* title, char* author, int quantity) {
    if (root == NULL) {
        return createNode(isbn, title, author, quantity);
    }

    if (isbn < root->isbn) {
        root->left = insertNode(root->left, isbn, title, author, quantity);
    } else if (isbn > root->isbn) {
        root->right = insertNode(root->right, isbn, title, author, quantity);
    } else {
        root->quantity += quantity;  // Update quantity if the book already exists
    }

    return root;
}

void inorderTraversal(Node* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("ISBN: %d, Title: %s, Author: %s, Quantity: %d\n", root->isbn, root->title, root->author, root->quantity);
        inorderTraversal(root->right);
    }
}

int main() {
    Node* root = NULL;

    int isbn, quantity;
    char title[100], author[100];

    while (1) {
        printf("\nLibrary Management System\n");
        printf("1. Insert a Book\n");
        printf("2. Display All Books\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter ISBN: ");
                scanf("%d", &isbn);
                printf("Enter Title: ");
                getchar();  // Remove newline character from the buffer
                fgets(title, sizeof(title), stdin);
                title[strlen(title) - 1] = '\0';  // Remove newline character
                printf("Enter Author: ");
                fgets(author, sizeof(author), stdin);
                author[strlen(author) - 1] = '\0';  // Remove newline character
                printf("Enter Quantity: ");
                scanf("%d", &quantity);

                root = insertNode(root, isbn, title, author, quantity);
                printf("Book inserted successfully!\n");
                break;
            case 2:
                printf("\nAll Books:\n");
                inorderTraversal(root);
                break;
            case 3:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}


(b) Search for a Book
Hint: Prompt the user to enter the ISBN of a book to search for. Perform a binary
search in the BST to find the corresponding book node. If the book is found, display
its ISBN, title, author, and available quantity. If the book is not found, display a
suitable message.


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int isbn;
    char title[100];
    char author[100];
    int quantity;
    struct Node* left;
    struct Node* right;
} Node;

Node* createNode(int isbn, char* title, char* author, int quantity) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->isbn = isbn;
    strcpy(newNode->title, title);
    strcpy(newNode->author, author);
    newNode->quantity = quantity;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

Node* insertNode(Node* root, int isbn, char* title, char* author, int quantity) {
    if (root == NULL) {
        return createNode(isbn, title, author, quantity);
    }

    if (isbn < root->isbn) {
        root->left = insertNode(root->left, isbn, title, author, quantity);
    } else if (isbn > root->isbn) {
        root->right = insertNode(root->right, isbn, title, author, quantity);
    } else {
        root->quantity += quantity;  // Update quantity if the book already exists
    }

    return root;
}

Node* searchNode(Node* root, int isbn) {
    if (root == NULL || root->isbn == isbn) {
        return root;
    }

    if (isbn < root->isbn) {
        return searchNode(root->left, isbn);
    } else {
        return searchNode(root->right, isbn);
    }
}

void inorderTraversal(Node* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("ISBN: %d, Title: %s, Author: %s, Quantity: %d\n", root->isbn, root->title, root->author, root->quantity);
        inorderTraversal(root->right);
    }
}

int main() {
    Node* root = NULL;

    int isbn, quantity;
    char title[100], author[100];

    while (1) {
        printf("\nLibrary Management System\n");
        printf("1. Insert a Book\n");
        printf("2. Search for a Book\n");
        printf("3. Display All Books\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter ISBN: ");
                scanf("%d", &isbn);
                printf("Enter Title: ");
                getchar();  // Remove newline character from the buffer
                fgets(title, sizeof(title), stdin);
                title[strlen(title) - 1] = '\0';  // Remove newline character
                printf("Enter Author: ");
                fgets(author, sizeof(author), stdin);
                author[strlen(author) - 1] = '\0';  // Remove newline character
                printf("Enter Quantity: ");
                scanf("%d", &quantity);

                root = insertNode(root, isbn, title, author, quantity);
                printf("Book inserted successfully!\n");
                break;
            case 2:
                printf("Enter ISBN to search: ");
                scanf("%d", &isbn);
                Node* foundNode = searchNode(root, isbn);
                if (foundNode != NULL) {
                    printf("Book found:\n");
                    printf("ISBN: %d, Title: %s, Author: %s, Quantity: %d\n", foundNode->isbn, foundNode->title, foundNode->author, foundNode->quantity);
                } else {
                    printf("Book not found.\n");
                }
                break;
            case 3:
                printf("\nAll Books:\n");
                inorderTraversal(root);
                break;
            case 4:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}



(c) Display All Books
Hint: Traverse the BST in an In-order fashion and display the ISBN, title, author,
and available quantity of each book node.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int isbn;
    char title[100];
    char author[100];
    int quantity;
    struct Node* left;
    struct Node* right;
} Node;

Node* createNode(int isbn, char* title, char* author, int quantity) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->isbn = isbn;
    strcpy(newNode->title, title);
    strcpy(newNode->author, author);
    newNode->quantity = quantity;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

Node* insertNode(Node* root, int isbn, char* title, char* author, int quantity) {
    if (root == NULL) {
        return createNode(isbn, title, author, quantity);
    }

    if (isbn < root->isbn) {
        root->left = insertNode(root->left, isbn, title, author, quantity);
    } else if (isbn > root->isbn) {
        root->right = insertNode(root->right, isbn, title, author, quantity);
    } else {
        root->quantity += quantity;  // Update quantity if the book already exists
    }

    return root;
}

void displayBooks(Node* root) {
    if (root != NULL) {
        displayBooks(root->left);
        printf("ISBN: %d, Title: %s, Author: %s, Quantity: %d\n", root->isbn, root->title, root->author, root->quantity);
        displayBooks(root->right);
    }
}

int main() {
    Node* root = NULL;

    int isbn, quantity;
    char title[100], author[100];

    while (1) {
        printf("\nLibrary Management System\n");
        printf("1. Insert a Book\n");
        printf("2. Search for a Book\n");
        printf("3. Display All Books\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter ISBN: ");
                scanf("%d", &isbn);
                printf("Enter Title: ");
                getchar();  // Remove newline character from the buffer
                fgets(title, sizeof(title), stdin);
                title[strlen(title) - 1] = '\0';  // Remove newline character
                printf("Enter Author: ");
                fgets(author, sizeof(author), stdin);
                author[strlen(author) - 1] = '\0';  // Remove newline character
                printf("Enter Quantity: ");
                scanf("%d", &quantity);

                root = insertNode(root, isbn, title, author, quantity);
                printf("Book inserted successfully!\n");
                break;
            case 2:
                printf("Enter ISBN to search: ");
                scanf("%d", &isbn);
                // Search for the book and display its details
                break;
            case 3:
                printf("\nAll Books:\n");
                displayBooks(root);
                break;
            case 4:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}


(d) Update Book Quantity

Hint: Prompt the user to enter the ISBN of a book whose quantity needs to be up-
dated. Search for the book in the BST based on the ISBN and prompt the user to

enter a new quantity. Update the book’s quantity in the BST accordingly. Display a
message indicating that the book’s quantity has been updated.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int isbn;
    char title[100];
    char author[100];
    int quantity;
    struct Node* left;
    struct Node* right;
} Node;

Node* createNode(int isbn, char* title, char* author, int quantity) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->isbn = isbn;
    strcpy(newNode->title, title);
    strcpy(newNode->author, author);
    newNode->quantity = quantity;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

Node* insertNode(Node* root, int isbn, char* title, char* author, int quantity) {
    if (root == NULL) {
        return createNode(isbn, title, author, quantity);
    }

    if (isbn < root->isbn) {
        root->left = insertNode(root->left, isbn, title, author, quantity);
    } else if (isbn > root->isbn) {
        root->right = insertNode(root->right, isbn, title, author, quantity);
    } else {
        root->quantity += quantity;  // Update quantity if the book already exists
    }

    return root;
}

Node* searchNode(Node* root, int isbn) {
    if (root == NULL || root->isbn == isbn) {
        return root;
    }

    if (isbn < root->isbn) {
        return searchNode(root->left, isbn);
    } else {
        return searchNode(root->right, isbn);
    }
}

void updateBookQuantity(Node* root, int isbn, int newQuantity) {
    Node* nodeToUpdate = searchNode(root, isbn);
    if (nodeToUpdate != NULL) {
        nodeToUpdate->quantity = newQuantity;
        printf("Book quantity updated successfully!\n");
    } else {
        printf("Book not found.\n");
    }
}

void displayBooks(Node* root) {
    if (root != NULL) {
        displayBooks(root->left);
        printf("ISBN: %d, Title: %s, Author: %s, Quantity: %d\n", root->isbn, root->title, root->author, root->quantity);
        displayBooks(root->right);
    }
}

int main() {
    Node* root = NULL;

    int isbn, quantity;
    char title[100], author[100];

    while (1) {
        printf("\nLibrary Management System\n");
        printf("1. Insert a Book\n");
        printf("2. Search for a Book\n");
        printf("3. Display All Books\n");
        printf("4. Update Book Quantity\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter ISBN: ");
                scanf("%d", &isbn);
                printf("Enter Title: ");
                getchar();  // Remove newline character from the buffer
                fgets(title, sizeof(title), stdin);
                title[strlen(title) - 1] = '\0';  // Remove newline character
                printf("Enter Author: ");
                fgets(author, sizeof(author), stdin);
                author[strlen(author) - 1] = '\0';  // Remove newline character
                printf("Enter Quantity: ");
                scanf("%d", &quantity);

                root = insertNode(root, isbn, title, author, quantity);
                printf("Book inserted successfully!\n");
                break;
            case 2:
                printf("Enter ISBN to search: ");
                scanf("%d", &isbn);
                // Search for the book and display its details
                break;
            case 3:
                printf("\nAll Books:\n");
                displayBooks(root);
                break;
            case 4:
                printf("Enter ISBN of the book to update quantity: ");
                scanf("%d", &isbn);
                printf("Enter new quantity: ");
                scanf("%d", &quantity);
                updateBookQuantity(root, isbn, quantity);
                break;
            case 5:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}


(e) Remove a Book
Hint: Prompt the user to enter the ISBN of a book to remove it from the library.
Search for the book in the BST based on the ISBN and remove it from the BST if
found. Display a message indicating that the book has been removed. If the book is
not found, display a suitable message.


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int isbn;
    char title[100];
    char author[100];
    int quantity;
    struct Node* left;
    struct Node* right;
} Node;

Node* createNode(int isbn, char* title, char* author, int quantity) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->isbn = isbn;
    strcpy(newNode->title, title);
    strcpy(newNode->author, author);
    newNode->quantity = quantity;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

Node* insertNode(Node* root, int isbn, char* title, char* author, int quantity) {
    if (root == NULL) {
        return createNode(isbn, title, author, quantity);
    }

    if (isbn < root->isbn) {
        root->left = insertNode(root->left, isbn, title, author, quantity);
    } else if (isbn > root->isbn) {
        root->right = insertNode(root->right, isbn, title, author, quantity);
    } else {
        root->quantity += quantity;  // Update quantity if the book already exists
    }

    return root;
}

Node* searchNode(Node* root, int isbn) {
    if (root == NULL || root->isbn == isbn) {
        return root;
    }

    if (isbn < root->isbn) {
        return searchNode(root->left, isbn);
    } else {
        return searchNode(root->right, isbn);
    }
}

Node* findMinNode(Node* node) {
    Node* current = node;
    while (current && current->left != NULL) {
        current = current->left;
    }
    return current;
}

Node* removeNode(Node* root, int isbn) {
    if (root == NULL) {
        return root;
    }

    if (isbn < root->isbn) {
        root->left = removeNode(root->left, isbn);
    } else if (isbn > root->isbn) {
        root->right = removeNode(root->right, isbn);
    } else {
        if (root->left == NULL) {
            Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            Node* temp = root->left;
            free(root);
            return temp;
        }

        Node* minNode = findMinNode(root->right);
        root->isbn = minNode->isbn;
        root->quantity = minNode->quantity;
        strcpy(root->title, minNode->title);
        strcpy(root->author, minNode->author);
        root->right = removeNode(root->right, minNode->isbn);
    }

    return root;
}

void displayBooks(Node* root) {
    if (root != NULL) {
        displayBooks(root->left);
        printf("ISBN: %d, Title: %s, Author: %s, Quantity: %d\n", root->isbn, root->title, root->author, root->quantity);
        displayBooks(root->right);
    }
}

int main() {
    Node* root = NULL;

    int isbn, quantity;
    char title[100], author[100];

    while (1) {
        printf("\nLibrary Management System\n");
        printf("1. Insert a Book\n");
        printf("2. Search for a Book\n");
        printf("3. Display All Books\n");
        printf("4. Update Book Quantity\n");
        printf("5. Remove a Book\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter ISBN: ");
                scanf("%d", &isbn);
                printf("Enter Title: ");
                getchar();  // Remove newline character from the buffer
                fgets(title, sizeof(title), stdin);
                title[strlen(title) - 1] = '\0';  // Remove newline character
                printf("Enter Author: ");
                fgets(author, sizeof(author), stdin);
                author[strlen(author) - 1] = '\0';  // Remove newline character
                printf("Enter Quantity: ");
                scanf("%d", &quantity);

                root = insertNode(root, isbn, title, author, quantity);
                printf("Book inserted successfully!\n");
                break;
            case 2:
                printf("Enter ISBN to search: ");
                scanf("%d", &isbn);
                // Search for the book and display its details
                break;
            case 3:
                printf("\nAll Books:\n");
                displayBooks(root);
                break;
            case 4:
                printf("Enter ISBN of the book to update quantity: ");
                scanf("%d", &isbn);
                printf("Enter new quantity: ");
                scanf("%d", &quantity);
                updateBookQuantity(root, isbn, quantity);
                break;
            case 5:
                printf("Enter ISBN of the book to remove: ");
                scanf("%d", &isbn);
                root = removeNode(root, isbn);
                printf("Book removed successfully!\n");
                break;
            case 6:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}

2. In a hospital’s emergency department, the system uses a Binary Heap to manage the pri-
ority of patients waiting for treatment. Each patient is assigned a priority value, where a

lower value indicates a higher priority. The Binary Heap is a min-heap, where the patient
with the highest priority has the smallest priority value.
Write a C program that implements the following operations for managing the patient
queue:
(a) Add a Patient
Hint: Prompt the user to enter the patient ID, name and priority of a patient. Create a
new patient node with the provided information and add it to the Binary Heap based
on the priority value.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Patient {
    int id;
    char name[100];
    int priority;
} Patient;

typedef struct PriorityQueue {
    Patient** heap;
    int capacity;
    int size;
} PriorityQueue;

Patient* createPatient(int id, char* name, int priority) {
    Patient* newPatient = (Patient*)malloc(sizeof(Patient));
    newPatient->id = id;
    strcpy(newPatient->name, name);
    newPatient->priority = priority;
    return newPatient;
}

PriorityQueue* createPriorityQueue(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->heap = (Patient**)malloc(capacity * sizeof(Patient*));
    return pq;
}

void swapPatients(Patient** patient1, Patient** patient2) {
    Patient* temp = *patient1;
    *patient1 = *patient2;
    *patient2 = temp;
}

void heapifyUp(PriorityQueue* pq, int index) {
    int parent = (index - 1) / 2;
    if (index > 0 && pq->heap[index]->priority < pq->heap[parent]->priority) {
        swapPatients(&pq->heap[index], &pq->heap[parent]);
        heapifyUp(pq, parent);
    }
}

void enqueue(PriorityQueue* pq, Patient* patient) {
    if (pq->size == pq->capacity) {
        printf("Priority Queue is full. Cannot add more patients.\n");
        return;
    }
    pq->heap[pq->size] = patient;
    heapifyUp(pq, pq->size);
    pq->size++;
}

void displayPatients(PriorityQueue* pq) {
    printf("Waiting Queue:\n");
    for (int i = 0; i < pq->size; i++) {
        printf("ID: %d, Name: %s, Priority: %d\n", pq->heap[i]->id, pq->heap[i]->name, pq->heap[i]->priority);
    }
}

int main() {
    int capacity;
    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    PriorityQueue* pq = createPriorityQueue(capacity);

    while (1) {
        printf("\nPatient Queue Management System\n");
        printf("1. Add a Patient\n");
        printf("2. Treat a Patient\n");
        printf("3. Display Waiting Queue\n");
        printf("4. Check Patient Count\n");
        printf("5. Update Patient Priority\n");
        printf("6. Clear Waiting Queue\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int id, priority;
                char name[100];
                printf("Enter patient ID: ");
                scanf("%d", &id);
                printf("Enter patient name: ");
                getchar();  // Remove newline character from the buffer
                fgets(name, sizeof(name), stdin);
                name[strlen(name) - 1] = '\0';  // Remove newline character
                printf("Enter patient priority: ");
                scanf("%d", &priority);

                Patient* newPatient = createPatient(id, name, priority);
                enqueue(pq, newPatient);
                printf("Patient added to the queue successfully!\n");
                break;
            }
            case 2:
                // Treat a Patient
                break;
            case 3:
                displayPatients(pq);
                break;
            case 4:
                printf("Total number of patients in the waiting queue: %d\n", pq->size);
                break;
            case 5:
                // Update Patient Priority
                break;
            case 6:
                // Clear Waiting Queue
                break;
            case 7:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}


(b) Treat a Patient
Hint: Remove and retrieve the patient with the highest priority (the root of the Binary
Heap). Display the patient ID, name and priority of the treated patient.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Patient {
    int id;
    char name[100];
    int priority;
} Patient;

typedef struct PriorityQueue {
    Patient** heap;
    int capacity;
    int size;
} PriorityQueue;

Patient* createPatient(int id, char* name, int priority) {
    Patient* newPatient = (Patient*)malloc(sizeof(Patient));
    newPatient->id = id;
    strcpy(newPatient->name, name);
    newPatient->priority = priority;
    return newPatient;
}

PriorityQueue* createPriorityQueue(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->heap = (Patient**)malloc(capacity * sizeof(Patient*));
    return pq;
}

void swapPatients(Patient** patient1, Patient** patient2) {
    Patient* temp = *patient1;
    *patient1 = *patient2;
    *patient2 = temp;
}

void heapifyDown(PriorityQueue* pq, int index) {
    int leftChild = 2 * index + 1;
    int rightChild = 2 * index + 2;
    int smallest = index;

    if (leftChild < pq->size && pq->heap[leftChild]->priority < pq->heap[smallest]->priority) {
        smallest = leftChild;
    }

    if (rightChild < pq->size && pq->heap[rightChild]->priority < pq->heap[smallest]->priority) {
        smallest = rightChild;
    }

    if (smallest != index) {
        swapPatients(&pq->heap[index], &pq->heap[smallest]);
        heapifyDown(pq, smallest);
    }
}

Patient* dequeue(PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty. No patients to treat.\n");
        return NULL;
    }

    Patient* treatedPatient = pq->heap[0];
    pq->heap[0] = pq->heap[pq->size - 1];
    pq->size--;
    heapifyDown(pq, 0);

    return treatedPatient;
}

void displayPatients(PriorityQueue* pq) {
    printf("Waiting Queue:\n");
    for (int i = 0; i < pq->size; i++) {
        printf("ID: %d, Name: %s, Priority: %d\n", pq->heap[i]->id, pq->heap[i]->name, pq->heap[i]->priority);
    }
}

int main() {
    int capacity;
    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    PriorityQueue* pq = createPriorityQueue(capacity);

    while (1) {
        printf("\nPatient Queue Management System\n");
        printf("1. Add a Patient\n");
        printf("2. Treat a Patient\n");
        printf("3. Display Waiting Queue\n");
        printf("4. Check Patient Count\n");
        printf("5. Update Patient Priority\n");
        printf("6. Clear Waiting Queue\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int id, priority;
                char name[100];
                printf("Enter patient ID: ");
                scanf("%d", &id);
                printf("Enter patient name: ");
                getchar(); // Clear the newline character from the input buffer
                fgets(name, sizeof(name), stdin);
                name[strlen(name) - 1] = '\0'; // Remove the trailing newline character from the name
                printf("Enter patient priority: ");
                scanf("%d", &priority);

                Patient* newPatient = createPatient(id, name, priority);
                if (pq->size == pq->capacity) {
                    printf("Priority Queue is full. Cannot add more patients.\n");
                } else {
                    pq->heap[pq->size] = newPatient;
                    pq->size++;
                    // Perform heapify up to maintain the min-heap property
                    int index = pq->size - 1;
                    while (index > 0 && pq->heap[index]->priority < pq->heap[(index - 1) / 2]->priority) {
                        swapPatients(&pq->heap[index], &pq->heap[(index - 1) / 2]);
                        index = (index - 1) / 2;
                    }
                    printf("Patient added to the waiting queue.\n");
                }
                break;
            }
            case 2: {
                Patient* treatedPatient = dequeue(pq);
                if (treatedPatient != NULL) {
                    printf("Treated Patient:\n");
                    printf("ID: %d, Name: %s, Priority: %d\n", treatedPatient->id, treatedPatient->name, treatedPatient->priority);
                    free(treatedPatient);
                }
                break;
            }
            case 3:
                displayPatients(pq);
                break;
            case 4:
                printf("Total number of patients in the waiting queue: %d\n", pq->size);
                break;
            case 5:
                // Update Patient Priority
                break;
            case 6:
                // Clear Waiting Queue
                break;
            case 7:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Patient {
    int id;
    char name[100];
    int priority;
} Patient;

typedef struct PriorityQueue {
    Patient** heap;
    int capacity;
    int size;
} PriorityQueue;

Patient* createPatient(int id, char* name, int priority) {
    Patient* newPatient = (Patient*)malloc(sizeof(Patient));
    newPatient->id = id;
    strcpy(newPatient->name, name);
    newPatient->priority = priority;
    return newPatient;
}

PriorityQueue* createPriorityQueue(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->heap = (Patient**)malloc(capacity * sizeof(Patient*));
    return pq;
}

void swapPatients(Patient** patient1, Patient** patient2) {
    Patient* temp = *patient1;
    *patient1 = *patient2;
    *patient2 = temp;
}

void heapifyDown(PriorityQueue* pq, int index) {
    int leftChild = 2 * index + 1;
    int rightChild = 2 * index + 2;
    int smallest = index;

    if (leftChild < pq->size && pq->heap[leftChild]->priority < pq->heap[smallest]->priority) {
        smallest = leftChild;
    }

    if (rightChild < pq->size && pq->heap[rightChild]->priority < pq->heap[smallest]->priority) {
        smallest = rightChild;
    }

    if (smallest != index) {
        swapPatients(&pq->heap[index], &pq->heap[smallest]);
        heapifyDown(pq, smallest);
    }
}

Patient* dequeue(PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty. No patients to treat.\n");
        return NULL;
    }

    Patient* treatedPatient = pq->heap[0];
    pq->heap[0] = pq->heap[pq->size - 1];
    pq->size--;
    heapifyDown(pq, 0);

    return treatedPatient;
}

void displayPatients(PriorityQueue* pq) {
    printf("Waiting Queue:\n");
    for (int i = 0; i < pq->size; i++) {
        printf("ID: %d, Name: %s, Priority: %d\n", pq->heap[i]->id, pq->heap[i]->name, pq->heap[i]->priority);
    }
}

int main() {
    int capacity;
    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    PriorityQueue* pq = createPriorityQueue(capacity);

    while (1) {
        printf("\nPatient Queue Management System\n");
        printf("1. Add a Patient\n");
        printf("2. Treat a Patient\n");
        printf("3. Display Waiting Queue\n");
        printf("4. Check Patient Count\n");
        printf("5. Update Patient Priority\n");
        printf("6. Clear Waiting Queue\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int id, priority;
                char name[100];
                printf("Enter patient ID: ");
                scanf("%d", &id);
                printf("Enter patient name: ");
                getchar(); // Clear the newline character from the input buffer
                fgets(name, sizeof(name), stdin);
                name[strlen(name) - 1] = '\0'; // Remove the trailing newline character from the name
                printf("Enter patient priority: ");
                scanf("%d", &priority);

                Patient* newPatient = createPatient(id, name, priority);
                if (pq->size == pq->capacity) {
                    printf("Priority Queue is full. Cannot add more patients.\n");
                } else {
                    pq->heap[pq->size] = newPatient;
                    pq->size++;
                    // Perform heapify up to maintain the min-heap property
                    int index = pq->size - 1;
                    while (index > 0 && pq->heap[index]->priority < pq->heap[(index - 1) / 2]->priority) {
                        swapPatients(&pq->heap[index], &pq->heap[(index - 1) / 2]);
                        index = (index - 1) / 2;
                    }
                    printf("Patient added to the waiting queue.\n");
                }
                break;
            }
            case 2: {
                Patient* treatedPatient = dequeue(pq);
                if (treatedPatient != NULL) {
                    printf("Treated Patient:\n");
                    printf("ID: %d, Name: %s, Priority: %d\n", treatedPatient->id, treatedPatient->name, treatedPatient->priority);
                    free(treatedPatient);
                }
                break;
            }
            case 3:
                displayPatients(pq);
                break;
            case 4:
                printf("Total number of patients in the waiting queue: %d\n", pq->size);
                break;
            case 5:
                // Update Patient Priority
                break;
            case 6:
                // Clear Waiting Queue
                break;
            case 7:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Patient {
    int id;
    char name[100];
    int priority;
} Patient;

typedef struct PriorityQueue {
    Patient** heap;
    int capacity;
    int size;
} PriorityQueue;

Patient* createPatient(int id, char* name, int priority) {
    Patient* newPatient = (Patient*)malloc(sizeof(Patient));
    newPatient->id = id;
    strcpy(newPatient->name, name);
    newPatient->priority = priority;
    return newPatient;
}

PriorityQueue* createPriorityQueue(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->heap = (Patient**)malloc(capacity * sizeof(Patient*));
    return pq;
}

void swapPatients(Patient** patient1, Patient** patient2) {
    Patient* temp = *patient1;
    *patient1 = *patient2;
    *patient2 = temp;
}

void heapifyDown(PriorityQueue* pq, int index) {
    int leftChild = 2 * index + 1;
    int rightChild = 2 * index + 2;
    int smallest = index;

    if (leftChild < pq->size && pq->heap[leftChild]->priority < pq->heap[smallest]->priority) {
        smallest = leftChild;
    }

    if (rightChild < pq->size && pq->heap[rightChild]->priority < pq->heap[smallest]->priority) {
        smallest = rightChild;
    }

    if (smallest != index) {
        swapPatients(&pq->heap[index], &pq->heap[smallest]);
        heapifyDown(pq, smallest);
    }
}

Patient* dequeue(PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty. No patients to treat.\n");
        return NULL;
    }

    Patient* treatedPatient = pq->heap[0];
    pq->heap[0] = pq->heap[pq->size - 1];
    pq->size--;
    heapifyDown(pq, 0);

    return treatedPatient;
}

void displayPatients(PriorityQueue* pq) {
    printf("Waiting Queue:\n");
    for (int i = 0; i < pq->size; i++) {
        printf("ID: %d, Name: %s, Priority: %d\n", pq->heap[i]->id, pq->heap[i]->name, pq->heap[i]->priority);
    }
}

int main() {
    int capacity;
    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    PriorityQueue* pq = createPriorityQueue(capacity);

    while (1) {
        printf("\nPatient Queue Management System\n");
        printf("1. Add a Patient\n");
        printf("2. Treat a Patient\n");
        printf("3. Display Waiting Queue\n");
        printf("4. Check Patient Count\n");
        printf("5. Update Patient Priority\n");
        printf("6. Clear Waiting Queue\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int id, priority;
                char name[100];
                printf("Enter patient ID: ");
                scanf("%d", &id);
                printf("Enter patient name: ");
                getchar(); // Clear the newline character from the input buffer
                fgets(name, sizeof(name), stdin);
                name[strlen(name) - 1] = '\0'; // Remove the trailing newline character from the name
                printf("Enter patient priority: ");
                scanf("%d", &priority);

                Patient* newPatient = createPatient(id, name, priority);
                if (pq->size == pq->capacity) {
                    printf("Priority Queue is full. Cannot add more patients.\n");
                } else {
                    pq->heap[pq->size] = newPatient;
                    pq->size++;
                    // Perform heapify up to maintain the min-heap property
                    int index = pq->size - 1;
                    while (index > 0 && pq->heap[index]->priority < pq->heap[(index - 1) / 2]->priority) {
                        swapPatients(&pq->heap[index], &pq->heap[(index - 1) / 2]);
                        index = (index - 1) / 2;
                    }
                    printf("Patient added to the waiting queue.\n");
                }
                break;
            }
            case 2: {
                Patient* treatedPatient = dequeue(pq);
                if (treatedPatient != NULL) {
                    printf("Treated Patient:\n");
                    printf("ID: %d, Name: %s, Priority: %d\n", treatedPatient->id, treatedPatient->name, treatedPatient->priority);
                    free(treatedPatient);
                }
                break;
            }
            case 3:
                displayPatients(pq);
                break;
            case 4:
                printf("Total number of patients in the waiting queue: %d\n", pq->size);
                break;
            case 5:
                // Update Patient Priority
                break;
            case 6:
                // Clear Waiting Queue
                break;
            case 7:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}


(c) Display Waiting Queue
Hint: Traverse the Binary Heap and display the names and priorities of all patients
in the waiting queue.


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Patient {
    int id;
    char name[100];
    int priority;
} Patient;

typedef struct PriorityQueue {
    Patient** heap;
    int capacity;
    int size;
} PriorityQueue;

Patient* createPatient(int id, char* name, int priority) {
    Patient* newPatient = (Patient*)malloc(sizeof(Patient));
    newPatient->id = id;
    strcpy(newPatient->name, name);
    newPatient->priority = priority;
    return newPatient;
}

PriorityQueue* createPriorityQueue(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->heap = (Patient**)malloc(capacity * sizeof(Patient*));
    return pq;
}

void swapPatients(Patient** patient1, Patient** patient2) {
    Patient* temp = *patient1;
    *patient1 = *patient2;
    *patient2 = temp;
}

void heapifyDown(PriorityQueue* pq, int index) {
    int leftChild = 2 * index + 1;
    int rightChild = 2 * index + 2;
    int smallest = index;

    if (leftChild < pq->size && pq->heap[leftChild]->priority < pq->heap[smallest]->priority) {
        smallest = leftChild;
    }

    if (rightChild < pq->size && pq->heap[rightChild]->priority < pq->heap[smallest]->priority) {
        smallest = rightChild;
    }

    if (smallest != index) {
        swapPatients(&pq->heap[index], &pq->heap[smallest]);
        heapifyDown(pq, smallest);
    }
}

Patient* dequeue(PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty. No patients to treat.\n");
        return NULL;
    }

    Patient* treatedPatient = pq->heap[0];
    pq->heap[0] = pq->heap[pq->size - 1];
    pq->size--;
    heapifyDown(pq, 0);

    return treatedPatient;
}

void displayPatients(PriorityQueue* pq) {
    printf("Waiting Queue:\n");
    for (int i = 0; i < pq->size; i++) {
        printf("Name: %s, Priority: %d\n", pq->heap[i]->name, pq->heap[i]->priority);
    }
}

int main() {
    int capacity;
    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    PriorityQueue* pq = createPriorityQueue(capacity);

    while (1) {
        printf("\nPatient Queue Management System\n");
        printf("1. Add a Patient\n");
        printf("2. Treat a Patient\n");
        printf("3. Display Waiting Queue\n");
        printf("4. Check Patient Count\n");
        printf("5. Update Patient Priority\n");
        printf("6. Clear Waiting Queue\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                // Add a Patient
                break;
            case 2:
                // Treat a Patient
                break;
            case 3:
                displayPatients(pq);
                break;
            case 4:
                // Check Patient Count
                break;
            case 5:
                // Update Patient Priority
                break;
            case 6:
                // Clear Waiting Queue
                break;
            case 7:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}

(d) Check Patient Count:
Hint: Calculate and display the total number of patients currently in the waiting
queue.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int patientID;
    char name[50];
    int priority;
} Patient;

typedef struct {
    Patient* patients;
    int capacity;
    int size;
} PriorityQueue;

PriorityQueue* createPriorityQueue(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->patients = (Patient*)malloc(capacity * sizeof(Patient));
    return pq;
}

void swapPatients(Patient* patient1, Patient* patient2) {
    Patient temp = *patient1;
    *patient1 = *patient2;
    *patient2 = temp;
}

void checkPatientCount(PriorityQueue* pq) {
    printf("Number of patients in the waiting queue: %d\n", pq->size);
}

int main() {
    int capacity;
    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    PriorityQueue* pq = createPriorityQueue(capacity);

    while (1) {
        printf("\nPatient Queue Management System\n");
        printf("1. Add a Patient\n");
        printf("2. Treat a Patient\n");
        printf("3. Display Waiting Queue\n");
        printf("4. Check Patient Count\n");
        printf("5. Update Patient Priority\n");
        printf("6. Clear Waiting Queue\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                // Add a Patient
                break;
            case 2:
                // Treat a Patient
                break;
            case 3:
                // Display Waiting Queue
                break;
            case 4:
                checkPatientCount(pq);
                break;
            case 5:
                // Update Patient Priority
                break;
            case 6:
                // Clear Waiting Queue
                break;
            case 7:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}


(e) Update Patient Priority
Hint: Prompt the user to enter the patient ID of a patient whose priority needs to be
updated. Retrieve the patient from the Binary Heap and prompt the user to enter a
new priority. Update the patient’s priority in the Binary Heap accordingly. Display
a message indicating that the patient’s priority has been updated.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int patientID;
    char name[50];
    int priority;
} Patient;

typedef struct {
    Patient* patients;
    int capacity;
    int size;
} PriorityQueue;

PriorityQueue* createPriorityQueue(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->patients = (Patient*)malloc(capacity * sizeof(Patient));
    return pq;
}

void swapPatients(Patient* patient1, Patient* patient2) {
    Patient temp = *patient1;
    *patient1 = *patient2;
    *patient2 = temp;
}

void updatePatientPriority(PriorityQueue* pq, int patientID, int newPriority) {
    int index = -1;
    for (int i = 0; i < pq->size; i++) {
        if (pq->patients[i].patientID == patientID) {
            index = i;
            break;
        }
    }

    if (index != -1) {
        pq->patients[index].priority = newPriority;

        // Perform heapify-up operation to maintain the min-heap property
        int childIndex = index;
        int parentIndex = (childIndex - 1) / 2;

        while (childIndex > 0 && pq->patients[childIndex].priority < pq->patients[parentIndex].priority) {
            swapPatients(&pq->patients[childIndex], &pq->patients[parentIndex]);
            childIndex = parentIndex;
            parentIndex = (childIndex - 1) / 2;
        }

        printf("Patient's priority has been updated.\n");
    } else {
        printf("Patient not found.\n");
    }
}

int main() {
    int capacity;
    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    PriorityQueue* pq = createPriorityQueue(capacity);

    while (1) {
        printf("\nPatient Queue Management System\n");
        printf("1. Add a Patient\n");
        printf("2. Treat a Patient\n");
        printf("3. Display Waiting Queue\n");
        printf("4. Check Patient Count\n");
        printf("5. Update Patient Priority\n");
        printf("6. Clear Waiting Queue\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                // Add a Patient
                break;
            case 2:
                // Treat a Patient
                break;
            case 3:
                // Display Waiting Queue
                break;
            case 4:
                // Check Patient Count
                break;
            case 5:
                // Update Patient Priority
                int patientID, newPriority;
                printf("Enter the patient ID: ");
                scanf("%d", &patientID);
                printf("Enter the new priority: ");
                scanf("%d", &newPriority);
                updatePatientPriority(pq, patientID, newPriority);
                break;
            case 6:
                // Clear Waiting Queue
                break;
            case 7:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}


(f) Clear Waiting Queue
Hint: Remove all patients from the Binary Heap and display a message indicating
that the waiting queue has been cleared.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int patientID;
    char name[50];
    int priority;
} Patient;

typedef struct {
    Patient* patients;
    int capacity;
    int size;
} PriorityQueue;

PriorityQueue* createPriorityQueue(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->patients = (Patient*)malloc(capacity * sizeof(Patient));
    return pq;
}

void clearWaitingQueue(PriorityQueue* pq) {
    pq->size = 0;
    printf("Waiting queue has been cleared.\n");
}

int main() {
    int capacity;
    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    PriorityQueue* pq = createPriorityQueue(capacity);

    while (1) {
        printf("\nPatient Queue Management System\n");
        printf("1. Add a Patient\n");
        printf("2. Treat a Patient\n");
        printf("3. Display Waiting Queue\n");
        printf("4. Check Patient Count\n");
        printf("5. Update Patient Priority\n");
        printf("6. Clear Waiting Queue\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                // Add a Patient
                break;
            case 2:
                // Treat a Patient
                break;
            case 3:
                // Display Waiting Queue
                break;
            case 4:
                // Check Patient Count
                break;
            case 5:
                // Update Patient Priority
                break;
            case 6:
                // Clear Waiting Queue
                clearWaitingQueue(pq);
                break;
            case 7:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}





